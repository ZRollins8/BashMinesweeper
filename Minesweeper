#!/bin/bash

#BASH MINESWEEPER
#by: Zane Rollins
#date: 2/4/2026
#Minesweeper that can be played in the terminal via the bash shell

clear

# CLI GUI Function
print_board() {
  echo ""
  echo "    Spaces Cleared: "$CLRSPC"   Flags Placed: "${!FLGARR[@]}
  echo ""
  echo "          1 2 3 4 5 6 7 8 9"
  echo "         %%%%%%%%%%%%%%%%%%%"
  for y in $(seq 0 10); do
    ROWARR=()
    for x in $(seq 0 8); do
      case $CELLTYPE in
      SAFE)
        ROWARR[x]="O"
        ;;
      FLAG)
        ROWARR[x]="F"
        ;;
      UNGES)
        ROWARR[x]="X"
        ;;
      esac
    done
    echo "       "${ALPH[y]}" |"${ROWARR[*]}"|"
  done
  echo "         %%%%%%%%%%%%%%%%%%%"
  echo ""
}

death_screen() {
echo "died"
DEAD=1
}

convert_coords() {

}

# Setup Board and variables
TARGETBOM=10
BOMNUM=0
BOMARR=(00)
CLRSPC=0
GUSTRK=()
GUSNUM=0
CELLTYPE="UNGES"
FLAGARR=()
ALPH=("A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K")
ERR="     What is your guess? :"
DEAD=0

#Generate Bomb Locations
while test $BOMNUM -lt $TARGETBOM; do

  #Run while less than target number of bombs
  GOODCHECK=1                            # Reset Checker
  BOMLOC=$((RANDOM % (100 - 1 + 1) + 1)) # Generate new random bomb position

  # Test if single digit number for formatting
  if test $BOMLOC -lt 10; then # If bomb location number is < 10
    BOMLOC="0"$BOMLOC          # add 0 to front of single digit number
  fi

  # Test if bomb is in repeat location
  for i in $( # for every bomb already placed
    seq 0 $((BOMNUM - 1))
  ); do
    if test $BOMLOC -eq ${BOMARR[i]}; then # if the new bomb is loacted in repeat spot
      GOODCHECK=0                          # Trip checker variable
    else                                   # if bomb location unique
      :                                    # continue through loop
    fi
  done

  # Test if checker has been tripped
  if test $GOODCHECK -eq 1; then # If checker is still good
    BOMARR[$BOMNUM]=$BOMLOC      # Add new location to array
    BOMNUM=$((BOMNUM + 1))       # Add to bomb count
  fi

done

while test $CLRSPC -lt 90 && test $DEAD -eq 0; do
  print_board
  echo "    "$ERR 
  read GUESSLOC
  GUESSX=${GUESSLOC:0:1}
  GUESSY=${GUESSLOC:1:2}
  ERRORCKX=0
  ERRORCKY=0
  ERRORCK=0

  if [[ $GUESSX =~ ^[+-]?[0-9]+$ ]]; then
    :
  else
    ERR="!!X guess is not a number!!" 
    ERRORCKX=1
  fi

  if test $ERRORCKX -eq 0; then
    if test $GUESSX -lt 1; then
      ERR="!!0 is not on the board!!"
      ERRORCKX=1
    fi
  fi


  if [[ $GUESSY =~ ^[+-]?[0-9]+$ ]]; then
    ERR="!!Y guess is not a letter"
    ERRORCKY=1
  else
    :
  fi

  if test $ERRORCKY -eq 0; then	
    ERRORCKY=1
    for t in $(seq 0 10); do
    	if [[ "$GUESSY" == "${ALPH[t]}" ]] ; then	
		ERRORCKY=0
    	fi
    done 
    if test $ERRORCKY -eq 1; then
	ERR="!!Y guess is not in range!!"
    fi
  fi

  for n in $(seq 0 $((CLRSPC-1))); do
   if [[ "$GUESSLOC" == "${GUSTRK[n]}" ]] ; then	
      ERRORCK=1
      ERR="!!Space has already been cleared!!" 
   fi
 done


  if test $ERRORCKY -eq 1 || test $ERRORCKX -eq 1 || test $ERRORCK -eq 1; then
	  echo "bad"
	  #:
  else

        for m in $(seq 0 $((TARGETBOM-1))); do
		if [[ "$GUESSLOC" == "${BOMARR[m]}" ]]; then
		   death_screen
		else
		   ERR="     Which space to clear? :"
		   GUSTRK[$CLRSPC]=$GUESSLOC
		   CLRSPC=$((CLRSPC+1))
		fi
	done
  fi

  clear
done

# TEST OUTPUT
#echo $BOMNUM
#echo $BOMLOC
#echo ${BOMARR[*]}
#print_board
